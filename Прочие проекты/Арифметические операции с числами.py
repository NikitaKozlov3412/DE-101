# -*- coding: utf-8 -*-

#Арифметические операции с присвоением (примеры)

number = 10
number += 5
print(number)  # 15
 
number -= 3
print(number)  # 12
 
number *= 4
print(number)  # 48

'''
При операциях с числами типа float надо учитывать, что результат операций с 
ними может быть не совсем точным. Например:
'''

first_number = 2.0001
second_number = 0.1
third_number = first_number + second_number
print(third_number)  # 2.1001000000000003


'''
В случае выше для округления результата мы можем использовать встроенную 
функцию round():

'''
first_number = 2.0001
second_number = 0.1
third_number = first_number + second_number
print(round(third_number))  # 2


'''
Функция round() также может принимать второе число, которое указывает, 
сколько знаков после запятой должно содержать получаемое число:
'''

first_number = 2.0001
second_number = 0.1
third_number = first_number + second_number
print(round(third_number, 4))  # 2.1001

'''
Однако если округляемая часть равна одинаково удалена от двух целых чисел, 
то округление идет к ближайшему четному:


'''

print(round(2.5))   # 2 - ближайшее четное
print(round(3.5))   # 4 - ближайшее четное

'''
Округление производится до ближайшего кратного 10 в степени минус 
округляемая часть:


'''

# округление до двух знаков после запятой
print(round(2.554, 2))      # 2.55
print(round(2.5551, 2))      # 2.56
print(round(2.554999, 2))   # 2.55
print(round(2.499, 2))      # 2.5

'''
В Python в связи с тем, что десятичная часть числа не может быть точно 
представлена в виде числа float, то это может приводить к некоторым 
не совсем ожидаемым результатам. Например:
'''

# округление до двух знаков после запятой
print(round(2.545, 2))   # 2.54
print(round(2.555, 2))   # 2.56 - округление до четного
print(round(2.565, 2))   # 2.56
print(round(2.575, 2))   # 2.58
 
print(round(2.655, 2))   # 2.65 - округление не до четного
print(round(2.665, 2))   # 2.67
print(round(2.675, 2))   # 2.67

